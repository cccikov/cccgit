<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>事件委托</title>
    <style type="text/css">
        #wrap.active{
            background: red;
        }
    </style>
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        let p = document.getElementsByTagName('p');
        for(let i = 0,len = p.length;i<len;i++){
            p[i].addEventListener("click", function(e){
                console.log(this);
                console.log(e.target);
            }, false);
        }

        wrap.addEventListener("click", function(e){
            let target = e.target;
            if(target.id == "" && target.className.indexOf("text") >= 0 && target.tagName.toLocaleLowerCase() == "p"){
                console.dir(target);
                console.log(this);
            }
        }, false);

        // $("#wrap").on("click", "p", function() {
            // console.log(this);
        // });

        for(let i = 0;i<4;i++){
            $("<p class='text'>新p元素</p>").appendTo("#wrap");
        }





        function ClassList(dom,bool){
            this.dom = dom;
            this.classList = this.dom.className.match(/\S+/g);
            if(bool){//如果是true的时候,就变成是寄生构造函数模式
                var arr = this.classList;//由于this.classList是arr,所以指向同一个内存位置,所以classList改变,arr也会改变;但是这样的话,添加属性,this.classList同样也会添加属性.
                for(var i in this){//this就是ClassList的实例,所以this的属性方法全部获取
                    arr[i] = this[i];
                }
                return arr
            }
        }
        ClassList.prototype._setClassName = function(){
            this.dom.className = this.classList.join(" ");
        }
        ClassList.prototype.contains = function(str){
            if(!!str && typeof str == "string"){
                return this.classList.indexOf(str) != -1;
            }
            return false;
        }
        ClassList.prototype.add = function(str){
            if(typeof str == "string"){
                if(!this.contains(str)){
                    this.classList.push(str);
                    this._setClassName();
                }
            }
        }
        ClassList.prototype.remove = function(str){
            if(this.contains(str)){
                console.log("remove");
                let index = this.classList.indexOf(str);
                this.classList.splice(index,1);
                this._setClassName();
                this.remove(str);//通过递归方式去消除重复的class
            }
        }
        ClassList.prototype.toggle = function(str){
            if(this.contains(str)){
                this.remove(str);
            }else{
                this.add(str);
            }
        }

        let wrapList = new ClassList(wrap,true);
        console.log(wrapList);
        console.log(wrapList.classList);
        console.log(wrapList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList.classList);
        console.log(wrapList.contains("container"));
        console.log(wrapList.add("container"));
        console.log(wrapList.add());
        console.log(wrapList.remove("fuck2"));
        wrap.onclick = function(){
            wrapList.toggle("active")
            console.log(wrapList);
        }

// 构造函数是new的时候才运行的 , 所以如果prototype写在构造函数里面 , 特别是重写 :一new的时候就绑定prototype,再执行构造函数,但是构造函数里面重写,所以就会造成第一个实例的prototype没有修改到.


    });
    </script>
</head>

<body>
    <div class="wrap btn content container container wrap___---content" id="wrap">
        <p class="text">Lorem.</p>
        <p class="text">Lorem.</p>
        <p class="text">Lorem.</p>
    </div>
</body>

</html>
