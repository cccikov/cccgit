<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>js中传值的问题</title>
    <script type="text/javascript">
    </script>
</head>

<body>
    <p>如果一些类型的传递, 想实时同步传递过来的数据, 把这个数据做成函数是一个常见的选择</p>
    <input type="text" id="username" value="ccc">
    <input type="text" id="age" value="27">
    <script>
        var username = document.getElementById("username");
        var age = document.getElementById("age");


        /* 第一种 */
        var options = {
            username: username.value,
            age: age.value,
        };

        function Say(options) {
            function getData() { // 假设Say是一个类, getData是里面的一个方法, 会根据页面不同的数据做出不同的操作
                var keys = Object.keys(options);
                var obj = {};
                keys.forEach(function(item) {
                    obj[item] = options[item];
                });
                console.log(obj); // 操作
            }

            setInterval(getData, 1000); // getData的触发是根据某些事件, 或者是某些请求后触发, 所以是异步的
        }




        /* 第二种 */
        var options2 = {
            username: function() {
                return username.value;
            },
            age: function() {
                return age.value;
            },
        };

        function Say2(options) {
            function getData() {
                var keys = Object.keys(options);
                var obj = {};
                keys.forEach(function(item) {
                    obj[item] = options[item]();
                });
                console.log(obj);
            }

            setInterval(getData, 1000);
        }

        username.onkeydown = function(e) {
            options.event = e;
            options2.event = function() {
                return e;
            }
        }
        Say(options); // 一旦传入就不会变化, 操作结果永远都是这样, 肯定不行啦
        // Say2(options2); // 会实时变化







        {
            // 不使用函数
            let obj_a = {
                data: {
                    id: 123,
                    name: "ccc",
                    age: "18"
                }
            }
            let props = obj_a.data;
            // 变化
            obj_a.data = {
                id: 321,
                name: "csh",
                age: "17"
            } // obj_a.data 指向一个新对象，但是props没有再赋值等于obj_a.data，所以props还是指向原来的对象。
            console.log(props, obj_a.data);
        }{
            // 使用函数
            let obj_a = {
                data: {
                    id: 123,
                    name: "ccc",
                    age: "18"
                }
            }
            let props_fn = function(){
                return obj_a.data;
            }
            // 变化
            obj_a.data = {
                id: 321,
                name: "csh",
                age: "17"
            }
            console.log(props_fn(), obj_a.data); // 因为使用函数，每次调用都会赋值一次
        }
    </script>
    <p>ps:以上的对象, 指的都是狭义上的对象, 即引用类型</p>
</body>

</html>