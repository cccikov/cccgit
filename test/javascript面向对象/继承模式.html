<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>继承模式</title>
</head>
<body>
	<script type="text/javascript">
		/*
		 * 原型链继承
		 */ 
		/*function SuperType(){
			this.color=["red","blue","green"];
		}
		function SubType(){}
		SubType.prototype = new SuperType();
		var instance1 = new SubType();
		instance1.color.push("pink");
		var instance2 = new SubType();
		console.log(instance1.color,instance2.color);//["red", "blue", "green", "pink"] ["red", "blue", "green", "pink"]
		//用原型链方法继承的问题是，继承于父类的属性和方法是共享的，因为是在Subtype原型中*/

		/*
		 * 借助构造函数
		 */ 
		function Up(name){
			this.name = name;
			this.num = [1,2,3,4];
		};
		function Down(name){
			var that = this;
			Up.call(that,name);//继承于Up，Down里面的this就变成是Up的实例,并且可以传递参数，Up里面的实例属性也变成Down的实例属性
			this.str = ["a","b"];//实例属性
		};
		var a = new Down("aaa");
		a.num.push(5);
		var b = new Down("ccc");
		console.log(a.num,b.num);//[1, 2, 3, 4, 5] [1, 2, 3, 4]
		console.log(a,b);

		var aPro = Object.getPrototypeOf(a);
		console.dir(aPro);

		/*
		 *   组合继承 最常用
		 */ 
		function SuperType(name){
			this.name = name;
			this.color = ["red","blue","green"];
		};
		SuperType.prototype.sayName = function(){
			console.log(this.name);
		};
		SuperType.prototype.up1 = 1;

		function SubType(name,age){
			//继承属性
			SuperType.call(this,name);
			this.age = age;
			this.down1 = "down1";
		};


	</script>
</body>
</html>