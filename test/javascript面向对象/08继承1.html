<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="UTF-8">
		<title>继承</title>
	</head>

	<body>
		<script type="text/javascript">
			/*
			 * 原型链继承
			 */
		//Up引用类型
		function Up() {
			this.name = "up";
			this.sayHi = function() {
				console.log("hi,I`m Up");
			}
		};
		Up.prototype.getName = function() {
			console.log(this.name);
		};

		//Down引用类型
		function Down() {
			this.role = "son";
			this.sayGg = function(){
				console.log("glhf");
			}
		};
		Down.prototype = new Up();// Down继承了Up,Down的原型是Up的实例，所有在Up的属性和方法都被Down继承
		//这种覆盖prototype的写法只能写在构造函数外面,不能想动态原型模式那样写在构造函数里面。  构造函数里面不可以覆盖prototype , 只能添加属性 ; 要覆盖,只能在构造函数外面
		//因为重写prototype后，要在重写后创建的实例对象才是指向新的prototype，所以覆盖prototype这种写法若是写在构造函数里面，每新建一个实例对象，prototype就指向新的对象，所以下一个实例才是指向前一个prototype，所以第一个创建的对象就会都不到prototype的内容
		Down.prototype.getRole = function() {
			console.log(this.role);
		}

		//实例
		var instance = new Down();

		instance.sayHi();//hi,I`m Up
		instance.getName(); //up
		instance.getRole(); //son
		instance.sayGg();//glhf

		// 全部引用类型都继承于Object，也是通过原型链来继承的
		console.log(instance instanceof Down,instance instanceof Up,instance instanceof Object);//true true true
		console.log(Down.prototype.isPrototypeOf(instance),Up.prototype.isPrototypeOf(instance),Object.prototype.isPrototypeOf(instance));//true true true
		// 可以看出instance 同时是 Down Up Object的实例，Down继承于Up，而Up继承于Object。

		// 覆盖超类型（父类）中的方法
		Down.prototype.getName = function(){
			console.log("down");
		}
		instance.getName();//down
		var instance2 = new Up();
		instance2.getName();//up
		// 读取属性的时候，现在实例找，再在原型一直往上找，直至Object为止


		var instancePro = Object.getPrototypeOf(instance);
		console.log(instancePro);//Up
		var instanceProPro = Object.getPrototypeOf(instancePro);
		console.log(instanceProPro);//Object

		</script>
	</body>

</html>