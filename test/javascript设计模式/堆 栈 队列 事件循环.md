## 事件循环

node 和 浏览器 事件循环的区别

浏览器端的事件循环是，桟空了-在任务队列中读取任务（任务队列会有各种事件（异步的回调函数）等待执行）-放在桟中-桟空了-任务队列

node 由于有大量i/o操作 事件队列执行-io操作-io操作完成-回到事件队列等待执行（等待调用回调函数）-事件队列执行

node API接口基本都是异步的，大多数都是i/o请求等待完成触发回调函数；就类似浏览器端的ajax，setTimeout，Promise，都是基本发起就期待成功触发，但是浏览器端还有事件监听这种类似发布/订阅模式的模式。

node 在回调完成后，基本又有有新一轮的io操作，又会等待事件完成，触发回调...这类异步操作里面不断触发新的异步。

浏览器端比较少（虽然也会有，比如vue双向绑定，但是这是为了业务需求不是语言的本身设计特性），基本不会ajax里面不断有新的ajax，setTimeout里面不断有新的setTimeout（除了做动画），虽然也有但是起码不是每次像node那样基本每个任务都是这样。

个人理解，浏览器的事件循环，循环是指桟-任务队列之间的循环；而node的事件循环，循环更多指的是 io操作-事件触发（io操作完成）-新的io操作

---

任务队列和事件循环

JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）

首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。
异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。

JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。维基百科的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。

等同步操作执行完，再执行异步（任务队列）

```
console.log(Date.now())
for(var i=0;i<100000;i++){
    console.log(i);
}
console.log(Date.now())

setTimeout(() => {
    console.log("%chahah","font-size:100px");
    console.log(Date.now())
}, 0);
```